import [] : "import"

type Person = {
    name: String,
    age: Number,
    phone: String = "0400000000",
    email: String = "test@test.com",
    address: {
        street: String
    } = {
        street: "123 Fake St."
    }
}

println(Person)

/* Partial Type */
type PartialPerson = Partial(Person)
println(PartialPerson)

/* NestedPartial Type */
type NestedPartialPerson = NestedPartial(Person)
println(NestedPartialPerson)

type Ids = 1001 | 1002 | 1003 | 1004

/* Record Type */
type Rec = Record(Ids, Person)
const recExample = Rec {
    ["1001"]: Person { name: "John", age: 34 },
    ["1002"]: Person { name: "John", age: 34 },
    ["1003"]: Person { name: "John", age: 34 },
    ["1004"]: Person { name: "John", age: 34 }
}
println(recExample)

/* Exclude Type */
type ValidTypes = String | Number | Boolean
type JustBool = Exclude(ValidTypes, String | Number)
println(JustBool)

/* Extract Type */
type BunchOfTypes = String | Number | (() => Number) | (() => String) | ((x: String, y: String) => String)
type FunctionTypes = Extract(BunchOfTypes, Function)
println(FunctionTypes)

/* Pick Type */
type NameAndAge = Pick(Person, "name" | "age")
println(NameAndAge)

/* Omit Type */
type NotEmail = Omit(Person, "email")
println(NotEmail)

/* Nullable Type */
type MaybeString = Nullable(String)
println(MaybeString)

/* NonNullable Type */
type MaybeStringOrNum = String | Number | None
type RequiredStringOrNum = NonNullable(MaybeStringOrNum)
println(RequiredStringOrNum)

/* Intersect Type */
type Animal = {
    name: String,
    species: String,
    speed: Number,
    extinct: Boolean
}
type PersonAndAnimal = Intersect(Person, Animal)
println(PersonAndAnimal)

/* Common Type */
type CommonPersonAnimal = Common(Person, Animal)
println(CommonPersonAnimal)

/* ReturnType Type */
const add_nums = (a: Number, b: Number) => a + b
type AddNumsReturn = ReturnType(add_nums)
println(AddNumsReturn)

/* Parameters Type */
type AddNumsParams = Parameters(add_nums)
println(AddNumsParams)

/* Items Type */
type PersonItems = Items(Person)
println(PersonItems)

/* Length Type */
const characters = "hello world".chars()
type CharsLength = Length(characters)
println(CharsLength)

/* At Type */
type CharsAt6 = At(characters, 6)
println(CharsAt6)

/* Readonly Type */
var modifiable_obj = {
    name: "John",
    age: 34
}

modifiable_obj.age += 10

println(modifiable_obj)

var read_only_obj = Readonly(modifiable_obj)

/* Below is expected to error */
/* read_only_obj.age += 10 */

/* ListToObj Type */

const some_list = [1, 2, "hi", 4, "bye"]

type SomeObj = ListToObj(some_list)

const some_obj: SomeObj = SomeObj {
    ["1"]: 1,
    ["2"]: 2,
    hi: "hi",
    ["4"]: 4,
    bye: "bye"
}

const some_obj_fx = (x: SomeObj) => x["2"]

println(some_obj_fx)

typeof(some_obj_fx(some_obj)).println()

const ls = [1, "2", 3, "4", some_obj]
type bloop = [Number, String, Number, String, SomeObj]

MatchArray(ls, bloop).println()

import [] : string

type StringFuncs = () => {
    import string_funcs : string
    string_funcs
}

type Split[Str: String, Key: String] = {
    const split = StringFuncs().split
    Str.split(Key)
}

const url = "/home?a=wonderful&b=wow"
const param_str = Split(url, "?").At(1)
const params = Split(param_str, "&")

type MakeObjFromParams[L: List] = {
    var obj = {}
    params.map((e) => {
        const kv = e.Split("=")
        obj[kv[0]] = kv[1] as Literal
    })
    obj
}

type ParamObj = MakeObjFromParams(params)

const p: ParamObj = ParamObj {
    a: "wonderful", b: "wow"
}

println(p)

type GetDeepValue[T: Object, FirstKey: KeyOf(T), SecondKey: KeyOf(T[FirstKey])] 
    = T[FirstKey][SecondKey] as Literal

const obj = {
    foo: {
        a: true,
        b: 2
    },
    bar: {
        c: "cool",
        d: 2
    }
}

const value = GetDeepValue(obj, "bar", "c")

println(value)

const add = (x: Number, y: Number = 0) => x + y
const numToString = (x: Number) => string(x)
const stringToNum = (x: String) => number(x)

const compose = (x) => x.add(4).numToString()
println(compose)
println(compose(100))

type Substring[str: String, start: Number, end: Number] = {
	var substr = ""
	for (start..end, index, value) {
        if (!str[value]) {
            ret substr
        }
		substr += str[value]
	}
	ret substr
}

type StartsWith[x: String, str: String] = x.Substring(0, str.length()) == str

type KeysStartingWith[T: Object, K: String] = T.keys().filter((k) => k.StartsWith(K)) as Const

const some_object = {
    a: 1,
    aa: 2,
    ba: 3,
    bb: 4,
    aaa: 5
}

println(some_object)
println(KeysStartingWith(some_object, "b"))

const la = ["create", "update", "delete"]
const lb = ["create", "update", "delete", "read"]

println(la as Union | lb as Union)

type GetT = (T: Object, K: KeyOf(T) = "a"): ValueOf(T) => T[K] as Literal
const x: String = GetT({a: "John", b: "Stacey"}, "a")
println(x) // John