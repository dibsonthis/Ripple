import [] : string
import io

const contains = (list: [Any], elem: Any): Boolean => {
	for (list, i, v) {
		if (v == elem) {
			ret true
		}
	}

	false
}

type Node;

union MaybeNode {
	Node,
	None
}

type Meta {
	line: Number = 1,
	col: Number = 1
}

type NumNode {
	value: Number = 0,
	meta: Meta
}

type StringNode {
	value: String = "",
	meta: Meta
}

type IDNode {
	value: String = "",
	meta: Meta
}

type OpNode {
	value: String = "",
	left: MaybeNode = None,
	right: MaybeNode = None,
	meta: Meta
}

type ContainerNode {
	value: String = "",
	meta: Meta
}

type ConstDeclNode {
	name: String = "",
	value: MaybeNode = None,
	meta: Meta
}

type FuncCallNode {
	name: String = "",
	args: [Node] = [],
	meta: Meta
}

type ParenNode {
	elements: [Node] = [],
	meta: Meta
}

type EOFNode {}

union Node {
	NumNode,
	StringNode,
	IDNode,
	OpNode,
	ContainerNode,
	ConstDeclNode,
	FuncCallNode,
	ParenNode,
	EOFNode
}

union MaybeChar {String, None}

const alpha = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".chars()
const digits = "0123456789".chars()

type Lexer {
	index: Number = 0,
	line: Number = 1,
	col: Number = 1,
	source: String = "",
	filePath: String = "",
	current_char: MaybeChar = None,
	nodes: [Node] = [],
	load = (filePath: String) => {
		this.filePath = filePath
		this.source = io.readf(filePath)
		this.current_char = this.source[0]
	},
	advance = () => {
		this.index += 1
		if (this.current_char == "\n") {
			this.line += 1
		}
		this.col += 1
		this.current_char = this.source[this.index]
	},
	tokenize = (): [Node] => {
		// We have to do this because 'this' can't reliably be nested (yet) :(
		var self = this
		while (self.current_char) {
			// String
			if (self.current_char == "\"") {
				var str_node = StringNode { meta: Meta { line: self.line, col: self.col }}
				self.advance() // consume '"'
				while (self.current_char != "\"") {
					str_node.value += self.current_char
					self.advance()
				}
				self.advance() // consume '"'
				self.nodes.append(str_node)
			}
			// Number
			else if (digits.contains(self.current_char)) {
				var num_node = NumNode { meta: Meta { line: self.line, col: self.col } }
				var num_str = self.current_char
				self.advance()
				while (digits.contains(self.current_char) || self.current_char == ".") {
					num_str += self.current_char
					self.advance()
				}
				num_node.value = number(num_str)
				self.nodes.append(num_node)
			}
			// ID
			else if (alpha.contains(self.current_char) || self.current_char == "_") {
				var id_node = IDNode { meta: Meta { line: self.line, col: self.col } }
				while (alpha.contains(self.current_char) || digits.contains(self.current_char) || self.current_char == "_") {
					id_node.value += self.current_char
					self.advance()
				}
				self.nodes.append(id_node)
			}
			// Ops
			else if (self.current_char == "=" && self.source[self.index+1] == "=") {
				var op_node = OpNode { value: "==", meta: Meta { line: self.line, col: self.col } }
				self.advance() // consume
				self.advance() // consume
				self.nodes.append(op_node)
			}
			else if (self.current_char == "!" && self.source[self.index+1] == "=") {
				var op_node = OpNode { value: "!=", meta: Meta { line: self.line, col: self.col } }
				self.advance() // consume
				self.advance() // consume
				self.nodes.append(op_node)
			}
			else if (["+", "-", "*", "/", "=", ","].contains(self.current_char)) {
				var op_node = OpNode { value: self.current_char, meta: Meta { line: self.line, col: self.col } }
				self.advance() // consume
				self.nodes.append(op_node)
			}
			else if (["[", "]", "{", "}", "(", ")"].contains(self.current_char)) {
				var cont_node = ContainerNode { value: self.current_char, meta: Meta { line: self.line, col: self.col } }
				self.advance() // consume
				self.nodes.append(cont_node)
			} else {
				self.advance()
			}
		}
		
		self.nodes.append(EOFNode {})
		ret self.nodes
	}
}