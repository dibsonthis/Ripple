import [] : "lexer"

type Parser {
	current_node: MaybeNode = None,
	index: Number = 0,
	nodes: [Node] = [],
	advance = () => {
		this.index += 1
		this.current_node = this.nodes[this.index]
		//println(this.current_node)
	},
	reset = (i: Number) => {
		this.index = i
		this.current_node = this.nodes[this.index]
	},
	parse = (endFunc: Function, start: Number) => {
		var self = this
		while (this.current_node.endFunc()) {
			if (!this.current_node) {
				break;
			}
			if (this.current_node.typeof() == OpNode && (this.current_node.value == "*" || this.current_node.value == "/")) {
				if (self.current_node.left || self.current_node.right) {
					self.advance()
					continue
				}
				const left = self.nodes[self.index-1]
				const right = self.nodes[self.index+1]
				self.nodes[self.index].left = left
				self.nodes[self.index].right = right
				self.nodes.remove_at(self.index+1)
				self.nodes.remove_at(self.index-1)
				self.index -= 1
			}
			self.advance()
		}
		self.reset(start)
		while (this.current_node.endFunc()) {
			if (!this.current_node) {
				break;
			}
			if (this.current_node.typeof() == OpNode && (this.current_node.value == "+" || this.current_node.value == "-")) {
				if (self.current_node.left || self.current_node.right) {
					self.advance()
					continue
				}
				const left = self.nodes[self.index-1]
				const right = self.nodes[self.index+1]
				self.nodes[self.index].left = left
				self.nodes[self.index].right = right
				self.nodes.remove_at(self.index+1)
				self.nodes.remove_at(self.index-1)
				self.index -= 1
			}
			self.advance()
		}
		self.reset(start)
		while (this.current_node.endFunc()) {
			if (!this.current_node) {
				break;
			}
			if (this.current_node.typeof() == OpNode && this.current_node.value == ",") {
				if (self.current_node.left || self.current_node.right) {
					self.advance()
					continue
				}
				const left = self.nodes[self.index-1]
				const right = self.nodes[self.index+1]
				self.nodes[self.index].left = left
				self.nodes[self.index].right = right
				self.nodes.remove_at(self.index+1)
				self.nodes.remove_at(self.index-1)
				self.index -= 1
			}
			self.advance()
		}
		self.reset(start)
		while (this.current_node.endFunc()) {
			if (!this.current_node) {
				break;
			}
			if (this.current_node.typeof() == OpNode && this.current_node.value == "=") {
				const left = self.nodes[self.index-1]
				const right = self.nodes[self.index+1]
				self.nodes[self.index].left = left
				self.nodes[self.index].right = right
				self.nodes.remove_at(self.index+1)
				self.nodes.remove_at(self.index-1)
				self.index -= 1
			}
			self.advance()
		}
		self.reset(start)
		while (this.current_node.endFunc()) {
			if (!this.current_node) {
				break;
			}
			if (this.current_node.typeof() == IDNode && this.current_node.value == "const") {
				var constDecl = ConstDeclNode { meta: self.current_node.meta }
				const right = self.nodes[self.index+1]
				if (right.typeof() == OpNode && right.value == "=") {
					const name = right.left.value
					const value = right.right
					constDecl.name = name
					constDecl.value = value
					self.nodes[self.index] = constDecl
					self.nodes.remove_at(self.index+1)
				}
			}
			self.advance()
		}
		self.reset(start)
		while (this.current_node.endFunc()) {
			if (!this.current_node) {
				break;
			}
			if (this.current_node.typeof() == ContainerNode && this.current_node.value == "(") {
				var parenNode = ParenNode { meta: self.current_node.meta }
				self.nodes[this.index] = parenNode
				self.advance()
				const i = self.index
				self.parse((n: MaybeNode) => {
					n && n.value != ")"
					}, i)
				while (self.current_node && self.current_node.value != ")") {
					if (self.current_node.typeof() == ParenNode) {
						for (self.nodes[self.index].elements, _i, e) {
							parenNode.elements.append(e)
						}
					} else {
						parenNode.elements.append(self.nodes[self.index])
					}
					self.nodes.remove_at(self.index)
					self.current_node = self.nodes[self.index]
					if (self.current_node && self.current_node.value == ")") {
						break
					}
					self.advance()
				}
	
				self.nodes.remove_at(self.index)
				self.current_node = self.nodes[self.index]

				if (self.current_node && self.current_node.typeof() == EOFNode) {
					break
				}
			}
			self.advance()
		}
		self.reset(start)
		println(self.nodes, self.current_node)
		while (this.current_node.endFunc()) {
			if (!this.current_node) {
				break;
			}
			if (this.current_node.typeof() == IDNode && this.nodes[this.index+1].typeof() == ParenNode) {
				const name = this.current_node.value
				var funcCall = FuncCallNode { meta: self.current_node.meta, name: name }
				const right = self.nodes[self.index+1]
				funcCall.args = right.elements
				self.nodes[self.index] = funcCall
				self.nodes.remove_at(self.index+1)
			}
			self.advance()
		}
		self.reset(start)
	},
	parse = () => {
		this.parse((n: MaybeNode) => {
			n && n.typeof() != EOFNode
		}, 0)
	}
}