//import testing : "../testing"
import [assert, shouldBe, shouldNotBe] : "../testing"

const test_requests = () => {
	import requests

	const get_response = requests.get("https://24pullrequests.com/projects.json")
	const body = get_response.toJson()

	const res_type = type(body)

	shouldBe(res_type, "List")
	assert(!body.empty, "Body should not be empty")
}

const test_string = () => {
	import string

	extend List {
		last: () => self[self.length-1]
	}

	const str = "hello world"
	const last = str.split().last()
	shouldBe(last, "world")
	shouldNotBe(last, "")
}

const test_union = () => {
	union Status {
		"active",
		"inactive",
		"on-hold"
	}

	try {
		const status: Status = "deleted"
		// If we make it here, it means the union typecheck failed :(
		error("Union type check failed")
	} catch (e) {}

	try {
		const status: Status = "inactive"
	} catch (e) {
		// If we make it here, it means the union typecheck failed :(
		error("Union type check failed")
	}
}

const test_refinement_types = () => {
	import string

	extend List {
		last: () => self[self.length-1]
	}

	const getExt = (str: String) => str.split(".").last() 

	type CSVPath = (x: String) => getExt(x) == "csv"
	type TXTPath = (x: String) => getExt(x) == "txt"

	const open = (fileType: CSVPath) => "Opening \"csv\" file..."
	const open = (fileType: TXTPath) => "Opening \"txt\" file..."
	const open = (fileType) => f"Cannot open \"${getExt(fileType)}\" files."

	var res = open("blah.csv")
	shouldBe(res, "Opening \"csv\" file...")

	res = open("blah.txt")
	shouldBe(res, "Opening \"txt\" file...")

	res = open("blah.jar")
	shouldBe(res, "Cannot open \"jar\" files.")
}

const test_refinement_types_2 = () => {
	type PosNum = (num: Number) => num > 0
	type NegNum = (num: Number) => num < 0
	
	const numfunc = (num: PosNum) => "pos"
	const numfunc = (num: NegNum) => "neg"
	const numfunc = (num: Number) => "0"
	
	var res = numfunc(10)
	shouldBe(res, "pos")

	res = numfunc(0)
	shouldBe(res, "0")

	res = numfunc(-10)
	shouldBe(res, "neg")
}

const test_matrix_mul = () => {
	const Matrix = [[Number]]

	const new_matrix = (w: Number, h: Number): Matrix => {
		var matrix = []
		var row = []

		for (0..w, x) {
			row.append(0)
		}

		for (0..h, y) {
			var _row = row
			matrix.append(_row)
		}

		matrix
	}

	const copy_matrix = (matrix: Matrix): Matrix => {
		const w = matrix[0].length
		const h = matrix.length
		var copy = new_matrix(w, h)
		for (0..h, y) {
			for (0..w, x) {
				copy[y][x] = matrix[y][x]
			}
		}
		ret copy
	}

	const mmul = (a: Number, b: Matrix): Matrix => {
		if (b.empty) {
			ret b
		}
		var matrix = copy_matrix(b)
		for (0..matrix.length, y) {
			for (0..matrix[0].length, x) {
				matrix[y][x] = matrix[y][x] * a
			}
		}
		ret matrix
	}

	const mmul = (a: Matrix, b: Number): Matrix => {
		mmul(b, a)
	}

	const mmul = (a: Matrix, b: Matrix): Matrix => {
		var h = a.length
		if (b.empty) {
			ret a
		}
		var w = b[0].length

		var matrix = new_matrix(w, h)

		for (0..a.length, i) {
			for (0..b[0].length, j) {
				for (0..b.length, k) {
					matrix[i][j] += a[i][k] * b[k][j]
				}
			}
		}
		ret matrix
	}

	const m1 = [[12, 7, 3],
				[4, 5, 6],
				[7, 8, 9]]


	const m2 = [[5, 8, 1, 2],
				[6, 7, 3, 0],
				[4, 5, 9, 1]]

	const res1 = mmul(m1, 2)
	const res2 = mmul(10, m2)
	const res3 = mmul(m1, m2)

	shouldBe(res1, [[24, 14, 6], [8, 10, 12], [14, 16, 18]])
	shouldBe(res2, [[50, 80, 10, 20], [60, 70, 30, 0], [40, 50, 90, 10]])
	shouldBe(res3, [[114, 160, 60, 27], [74, 97, 73, 14], [119, 157, 112, 23]])
}

const test_custom_map = () => {
	import string
	
	extend List {
		map: (func: (x) => Any) => {
			var list = []
			for (self, index, value) {
				list.append(func(value))
			}
			list
		},
		map: (func: (x: Any, i: Number) => Any) => {
			var list = []
			for (self, index, value) {
				list.append(func(value, index))
			}
			list
		},
		map: (func: (x: Any, i: Number, ls: List) => Any) => {
			var list = []
			for (self, index, value) {
				list.append(func(value, index, self))
			}
			list
		}
	}

	const list = "My name is John Bartholomew Jacobson".split()
	const new_list = list.map((x, i) => x + " " + string(i))

	shouldBe(new_list, ["My 0", "name 1", "is 2", "John 3", "Bartholomew 4", "Jacobson 5"])
}

const test_object_map = () => {

	import string

	type Item {
		key: String, 
		value: Any
	}

	extend Object {
		map: (func: (item: Item) => Any) => {
			var new_obj = {}
			for (self.keys, index, key) {
				const value = self[key]
				new_obj[key] = func(Item {key: key, value: value})
			}
			new_obj
		}
	}

	const obj = {
		name: "John",
		age: 34,
		nums: [1, 3, 8, 16],
		address: {
			street: "123 Test St.",
			city: "Testville",
			postCode: 1234
		}
	}

	const new_obj = obj.map((item: Item) => {
		if (type(item.value) == "String") {
			ret item.value.chars()
		} else if (type(item.value) == "Number") {
			ret item.value * 2
		} else {
			ret item.value
		}
 	})

	shouldBe(new_obj.name, ["J", "o", "h", "n"])
	shouldBe(new_obj.age, 68)
	shouldBe(new_obj.nums, [1, 3, 8, 16])
}

const test_universal_function_calls = () => {
	type Vec2 {
		x: Number,
		y: Number
	}
	
	const add = (a: Number, b: Number): Number => a + b
	const add = (a: Vec2, b: Vec2): Vec2 => {
		Vec2 {
			x: a.x + b.x,
			y: a.y + b.y
		}
	}
	
	const vec1 = Vec2 { x: 12, y: 18 }
	const vec2 = Vec2 { x: 8, y: 2 }

	const res1 = (4.4).add(10)
	const res2 = vec1.add(vec2)

	shouldBe(res1, 14.4)
	shouldBe(res2, Vec2 { x: 20, y: 20 })
}

const test_universal_function_calls_lists = () => {
	union BoolOrNum {Boolean, Number}
	union StringOrNum {String, Number}

	const add = (a: [String], b: [String]): [String] => a + b;
	const add = (a: [Number], b: [Number]): [Number] => a + b;
	const add = (a: [String], b: [Number]): [StringOrNum] => a + b;
	const add = (a: [BoolOrNum], b: [Number]): [Number] => {
		a.map((x) => number(x)) + b
	};

	shouldBe(["a", "b"].add(["c", "d"]), ["a", "b", "c", "d"])
	shouldBe([1, 2, 3].add([4, 5, 6]), [1, 2, 3, 4, 5, 6])
	shouldBe(["a", "b"].add([4,5,6]), ["a", "b", 4, 5, 6])
	shouldBe([false, true, 2, 3].add([4,5,6]), [0, 1, 2, 3, 4, 5, 6])

	try {
		[true, false].add(false, true)
		error("UFC error handling failed")
	} catch (e) {
		// If we're here, we successfully threw and caught the error
		const add = (a: [Boolean], b: [Boolean]): [Boolean] => a + b
		const res = [true, false].add([false, true])
		shouldBe(res, [true, false, false, true])
	}
}