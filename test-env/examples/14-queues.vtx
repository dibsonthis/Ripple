import threading
import io

const QueueT = (T) => {
	type Queue_T {
		elements: [T] = [],
		pop = (): T => {
			const first = this.elements[0]
			this.elements.remove_at(0)
			first
		},
		add = (x: T) => {
			this.elements.append(x)
			this
		},
		peek = (): union _ {T, None} => {
			const first = this.elements[0]
			ret first
		},
		end = (): union _ {T, None} => {
			const last = this.elements[this.elements.length-1]
			ret last
		},
		empty = (): Boolean => this.elements.empty,
		raw = (): [T] => this.elements,
		size = (): Number => this.elements.length
	}
}

const NumQueue = QueueT(Number)
const num_q = NumQueue {}

const processQueue = (q: NumQueue) => {
	var running = true
	while (running) {
		if (q.end() == -2) {
			running = false
			println("\nResponse: Stopping immediately, batched tasks before or after this call will not be processed")
		}
		if (q.size() < 5) {
			continue
		}
		while (!q.empty()) {
			const element = q.pop()
			if (element == -1) {
				running = false
				println("\nResponse: Stopping, batched tasks after this call will not be processed")
				break
			} else if (element == 1) {
				println(f"\nResponse: Queue: ${q.raw()}")
			} else if (element == 69) {
				println("\nResponse: Hehe")
			} else {
				println(f"\nResponse: Invalid input: ${element}")
			}
		}
	}
}

const queueThread = threading.thread(processQueue, [num_q])

while (!queueThread.ready()) {
	print("\nRequest: ")
	const input = io.input()
	var num: Number = 0;
	try {
		num = number(input)
	} catch (e) {
		num = 0
	}
	
	num_q.add(num)
}